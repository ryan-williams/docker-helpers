#!/usr/bin/env python
#
# Make a .dockerignore file that only accepts files currently tracked by Git
#
# Install:
#
#     curl -L https://bit.ly/install-make-dockerignore > ~/bin/make-dockerignore.py
#     chmod ugo+x ~/bin/make-dockerignore.py
#
# See https://j.mp/make-dockerignore

from argparse import ArgumentParser
parser = ArgumentParser()
parser.add_argument('-G','--no-git-dir',action='store_true',help="When set, don't un-ignore the .git directory (i.e. ignore it)")
parser.add_argument('-d','--description',action='count',default=0,help="How verbose of a comment/header message to write")
parser.add_argument('-D','--no-description',action='store_true',help="When set, don't output any header message")
args = parser.parse_args()

no_git_dir = args.no_git_dir

if args.no_description:
  description = 0
else:
  description = args.description
  if description == 0:
        description = 1

import os.path
from pathlib import Path
import shlex
from subprocess import check_output as run
import sys

with open('.dockerignore','w') as f:
  # Render the current command (but stripping out directory bits from the path to this script)
  cmd = shlex.join([Path(sys.argv[0]).name] + sys.argv[1:])

  # Short URL for more info
  url = 'https://j.mp/make-dockerignore'

  includes = []

  def comment(m): f.write(('# %s' % m).strip() + '\n')
  def exclude(p): f.write('%s\n' % p)

  if description == 1:
    # Verbosity 1: small msg at top of .dockerignore file
    if len(sys.argv) > 1:
          cmd = '`%s`' % cmd
    f.write('# Generated by %s; see %s\n' % (cmd, url))
  elif description >= 2:
    # Verbosity 2: larger msg at top of .dockerignore file
    lines = [
      'Exclude all files except those tracked by Git.',
      '',
      'Generated by:',
      '',
      '\t%s' % cmd,
      '',
      'See %s' % url,
    ]

    [
      comment(line)
      for line in lines
    ]

  # ignore everything by default
  exclude('*')

  # maybe add the .git dir (useful for mounting the current working directory and having the git directory come along)
  if not no_git_dir:
    includes += ['.git']

  f.flush()

  # un-exclude all git-tracked files
  includes += run(['git','ls-files','--recurse-submodules']).decode().split('\n')

  # maybe un-exclude git submodules' git "directories" (typically .git files that point into the parent repo's .git/modules directory)
  if not no_git_dir:
    includes += [
      os.path.join(path,'.git')
      for path in
      run(['git','submodule','foreach','--recursive','--quiet','echo $displaypath']).decode().split('\n')
    ]

  includes = sorted(set(includes))
  [
    f.write(f'!{include}\n')
    for include in includes
    if include
  ]

